#include "geth_lwip.h"
#include "IfxStm.h"
#include "IfxGeth_Eth.h"
#include "IfxGeth.h"
#include "Configuration.h"
#include "ConfigurationIsr.h"
#include "Ifx_Lwip.h"
#include "IfxCpu_Irq.h"
#include "CompilerTasking.h"
#include "lwip/netif.h"
#include "etc.h"
#include "my_stdio.h"
#include <string.h>

void initStmForLwip (void);

static uint8 g_srcAddr[6];

void initLwip(eth_addr_t mac)
{
    initStmForLwip();
    for (int i = 0; i < 6; i++) {
        g_srcAddr[i] = mac.addr[i];
    }
    Ifx_Lwip_init(mac);
    delay_ms(3000);
//    while (netif_is_link_up(&g_Lwip.netif) == 0);
}

void initStmForLwip(void)
{
    IfxStm_CompareConfig stmCompareConfig; /* STM Configuration declaration                */

    IfxStm_initCompareConfig(&stmCompareConfig); /* Initialize a default configuration for STM   */

    stmCompareConfig.triggerPriority = ISR_PRIORITY_OS_TICK; /* Priority of the interrupt generated by STM   */
    stmCompareConfig.comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0; /* Select the request source 0                  */
    stmCompareConfig.ticks = IFX_CFG_STM_TICKS_PER_MS * 10; /* First interrupt shall occur after 10 ms      */
    stmCompareConfig.typeOfService = IfxSrc_Tos_cpu0; /* CPU0 serves the interrupts                   */

    IfxStm_initCompare(&MODULE_STM0, &stmCompareConfig); /* Initialize the Compare functionality         */
}

/* This interrupt is raised by the STM0 */
IFX_INTERRUPT(updateLwIPStackISR, 0, ISR_PRIORITY_OS_TICK);
/* ISR to update LwIP stack */
void updateLwIPStackISR(void)
{
    /* Configure STM to generate an interrupt in 1 ms */
    IfxStm_increaseCompare(&MODULE_STM0, IfxStm_Comparator_0, IFX_CFG_STM_TICKS_PER_MS);

    g_TickCount_1ms++; /* Increase LwIP system time                                    */

    Ifx_Lwip_onTimerTick(); /* Every 1 ms LwIP timers are increased for all the enabled
                             * protocols (ARP, TCP, DHCP, LINK)                             */
}

void geth_sendETH(uint8 *destAddr, uint8 *payload, int payloadLength)
{
    uint32 packetLength = IFXGETH_HEADER_LENGTH + payloadLength;

    // get free buffer
    uint8 *pTxBuf = (uint8*)IfxGeth_Eth_waitTransmitBuffer(&g_IfxGeth, IfxGeth_TxDmaChannel_0);

    // write the header
    IfxGeth_Eth_writeHeader(&g_IfxGeth, pTxBuf, (uint8*)destAddr, (uint8*)g_srcAddr, payloadLength);

    uint16 etherType = 0x0000;
    pTxBuf[12] = (uint8)(etherType >> 8);
    pTxBuf[13] = (uint8)(etherType & 0xFF);

    // write the payload
    for (int i = IFXGETH_HEADER_LENGTH; i < packetLength; ++i)
    {
        pTxBuf[i] = payload[i - IFXGETH_HEADER_LENGTH];
    }

    // clear the TX interrupt status
    IfxGeth_dma_clearInterruptFlag(g_IfxGeth.gethSFR, IfxGeth_DmaChannel_0, IfxGeth_DmaInterruptFlag_transmitInterrupt);

    IfxGeth_Eth_sendTransmitBuffer(&g_IfxGeth, packetLength, IfxGeth_TxDmaChannel_0);

    // wait until buffer has been transmitted
    while (IfxGeth_dma_isInterruptFlagSet(g_IfxGeth.gethSFR, IfxGeth_DmaChannel_0,
            IfxGeth_DmaInterruptFlag_transmitInterrupt) == FALSE);

    // clear the TX interrupt status for the next interrupt to come
    IfxGeth_dma_clearInterruptFlag(g_IfxGeth.gethSFR, IfxGeth_DmaChannel_0, IfxGeth_DmaInterruptFlag_transmitInterrupt);
}

int geth_recvETH(uint8 *buf)
{
    // wait until data is been received
    while(IfxGeth_Eth_isRxDataAvailable(&g_IfxGeth, IfxGeth_RxDmaChannel_0)!= TRUE);
    // wake up the receiver and get the recieve buffer
    uint8 *pRxBuf = (uint8*)IfxGeth_Eth_getReceiveBuffer(&g_IfxGeth, IfxGeth_RxDmaChannel_0);
    int payloadLength = 0;
    while (pRxBuf[14+payloadLength] != 0) {
        payloadLength++;
    }
    memcpy(buf, pRxBuf, payloadLength);

    // update the descreptor pointer for next packet
    // Free the receive buffer, enabling it for the further reception
    IfxGeth_Eth_freeReceiveBuffer(&g_IfxGeth, IfxGeth_RxDmaChannel_0);

    return payloadLength;
}
